(()=>{"use strict";class t{constructor(t){this.data=t,this.left=null,this.right=null}}const r=new class{constructor(t){this.root=this.buildTree(this.getArray(t))}getArray(t){return this.mergeSort([...new Set(t)])}buildTree(r,e=0,i=r.length-1){if(e>i)return null;const o=Math.floor((e+i)/2),s=new t(r[o]);return s.left=this.buildTree(r,e,o-1),s.right=this.buildTree(r,o+1,i),s}insert(r,e=this.root){return this.root?e?(r<e.data?e.left=this.insert(r,e.left):r>e.data&&(e.right=this.insert(r,e.right)),e):new t(r):this.root=new t(r)}delete(t,r=this.root){if(!r)return null;if(t<r.data)return r.left=this.delete(t,r.left),r;if(t>r.data)return r.right=this.delete(t,r.right),r;if(r.left){if(r.right){let t=r,e=r.right;for(;e.left;)t=e,e=e.left;return t!==r?t.left=e.right:t.right=e.right,r.data=e.data,r}return r.left}return r.right}find(t,r=this.root){return!!r&&(t<r.data?this.find(t,r.left):!(t>r.data)||this.find(t,r.right))}mergeSort(t){if(t.length<=1)return t;const r=Math.round(t.length/2),e=this.mergeSort(t.slice(0,r)),i=this.mergeSort(t.slice(r));return this.sort(e,i)}sort(t,r){const e=[];for(;t.length>0&&r.length>0;)t[0]<r[0]?e.push(t.shift()):e.push(r.shift());return e.concat(t,r)}levelOrder(t,r=[],e=[this.root]){if(!this.root||!e.length)return;const i=e.shift();return t?t(i):r.push(i.data),i.left&&e.push(i.left),i.right&&e.push(i.right),this.levelOrder(t,r,e),r}inOrder(t,r=this.root,e=[]){if(r)return this.inOrder(t,r.left,e),t?t(r):e.push(r.data),this.inOrder(t,r.right,e),e}preOrder(t,r=this.root,e=[]){if(r)return t?t(r):e.push(r.data),this.preOrder(t,r.left,e),this.preOrder(t,r.right,e),e}postOrder(t,r=this.root,e=[]){if(r)return this.postOrder(t,r.left,e),this.postOrder(t,r.right,e),t?t(r):e.push(r.data),e}height(t=this.root){if(!t)return-1;const r=this.height(t.left),e=this.height(t.right);return Math.max(r,e)+1}depth(t,r=this.root){if(!this.find(t))return;let e=0;return t<r.data?e=this.depth(t,r.left)+1:t>r.data&&(e=this.depth(t,r.right)+1),e}isBalanced(t=this.root){const r=this.height(t.left),e=this.height(t.right);return Math.abs(r-e)<=1}reBalance(){this.isBalanced()||(this.root=this.buildTree(this.mergeSort(this.levelOrder())))}prettyPrint(t=this.root,r="",e=!0){null!==t&&(null!==t.right&&this.prettyPrint(t.right,`${r}${e?"│   ":"    "}`,!1),console.log(`${r}${e?"└── ":"┌── "}${t.data}`),null!==t.left&&this.prettyPrint(t.left,`${r}${e?"    ":"│   "}`,!0))}}((10,Array.from({length:10},(()=>Math.floor(100*Math.random())))));r.prettyPrint(),console.log("Is balanced?",r.isBalanced()),console.log("Level Order:",r.levelOrder()),console.log("Preorder:",r.preOrder()),console.log("Inorder:",r.inOrder()),console.log("Postorder:",r.postOrder()),((t,r)=>{for(let r=0;r<10;r++){const r=Math.floor(899*Math.random()+101);t.insert(r)}})(r),r.prettyPrint(),console.log("Is balanced?",r.isBalanced()),r.reBalance(),console.log("Balancing Tree..."),r.prettyPrint(),console.log("Is balanced?",r.isBalanced()),console.log("Level Order:",r.levelOrder()),console.log("Preorder:",r.preOrder()),console.log("Inorder:",r.inOrder()),console.log("Postorder:",r.postOrder())})();